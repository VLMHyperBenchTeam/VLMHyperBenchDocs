# ADR-012: Использование Redis как Message Broker (Event Bus)

**Дата**: 2026-01-22
**Статус**: Принято

## Контекст
В архитектуре VLMHyperBench v0.2.0 система разделена на два слоя:
1. **Host Layer**: Где работает `Orchestrator Service`, управляющий GPU и Docker Engine.
2. **Container Layer**: Где работают `Management Backend`, `Web UI` и другие сервисы инфраструктуры.

Нам необходим механизм для передачи событий в реальном времени (логи, статусы задач, прогресс) от Оркестратора к Бекенду и далее к пользователю.

## Решение
Использовать **Redis** (механизм Pub/Sub) в качестве легковесного брокера сообщений (Message Broker).

### Схема взаимодействия
1. **Orchestrator Service** (Host) подписывается на внутренние события `orchestrator_core`.
2. При возникновении события Оркестратор публикует его в Redis в соответствующий канал (например, `experiment:{id}`).
3. **Management Backend** (Container) подписывается на каналы в Redis.
4. При получении сообщения Бекенд пробрасывает его в Web UI через WebSockets.

## Преимущества
1. **Слабая связанность (Decoupling)**: Сервисы не зависят от прямых сетевых адресов друг друга.
2. **Real-time**: Минимальные задержки при передаче сообщений.
3. **Масштабируемость**: К одному каналу событий могут быть подключены несколько независимых подписчиков (логирование, уведомления).
4. **Надежность**: Redis является проверенным инструментом, который уже присутствует в стеке инфраструктуры.

## Последствия
- Необходимо обеспечить доступность порта Redis (6379) как для контейнеров, так и для хоста.
- Сообщения в Redis Pub/Sub не сохраняются (fire-and-forget). Если Бекенд был офлайн в момент публикации, он не получит пропущенные сообщения. (Для критических данных в будущем возможно использование Redis Streams).