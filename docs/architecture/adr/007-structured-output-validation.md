# ADR-007: Валидация структурированного вывода и метрика Structural Fidelity

## Статус
Предложено (Proposed)

## Контекст
При оценке VLM на задачах извлечения полей документов (Information Extraction), ответ модели должен строго соответствовать заданной схеме (обычно JSON). Несмотря на использование технологий `constrained decoding` (в vLLM и SGLang), существует риск получения невалидного результата из-за сбоев инференса или ограничений контекста. Нам необходимо отделить ошибки формата от ошибок содержания.

## Решение
Мы внедряем обязательный слой валидации на этапе оценки и новую метрику качества.

### 1. Валидация через Pydantic
В модуль `DataParser` интегрируется библиотека **Pydantic**. 
- При инференсе в `model_params` передается JSON Schema.
- На этапе оценки `DataParser` использует эту схему для создания динамической модели Pydantic.
- Каждый ответ модели проходит через `model_validate_json()`.

### 2. Метрика Structural Fidelity
Вводится бинарная метрика `StructuralFidelity`:
- **1 (Success)**: JSON валиден и полностью соответствует схеме.
- **0 (Fail)**: JSON невалиден, отсутствуют обязательные поля или не совпадают типы данных.

## Последствия

### Плюсы
- **Чистота метрик**: Если формат невалиден, мы не считаем текстовые метрики (CER/ANLS) для этого объекта, что предотвращает искажение статистики.
- **Диагностика**: Метрика позволяет оценить, насколько хорошо конкретный бэкенд (vLLM vs SGLang vs HF) справляется с удержанием структуры.
- **Fail-fast**: Ошибки парсинга перехватываются на раннем этапе, обеспечивая стабильность `EvaluationRunner`.

### Минусы
- Незначительное увеличение времени оценки из-за работы валидатора.
- Необходимость строгого определения схем в конфигурациях экспериментов.

## Альтернативы
- **Простой JSON.loads()**: Не проверяет типы данных и наличие обязательных полей.
- **LLM-as-a-judge**: Слишком дорого и медленно для базовой проверки формата.