# ADR-011: Управление Реестрами и Режимы Исполнения (RUN_MODE)

## Статус
Предложено (Proposed)

## Контекст
Для версии v0.2.0 VLMHyperBench требуется гибкая система конфигурации, которая позволила бы:
1.  Разделить описание типов задач (`MLTask`) и конкретных запусков (`RunTask`).
2.  Поддерживать атомарные определения пакетов (датасеты, метрики, отчеты).
3.  Бесшовно переключаться между локальной разработкой (`dev`) и стабильными релизами (`prod`).
4.  Обеспечить строгую валидацию конфигураций перед запуском.

## Решение

### 1. Атомарные Реестры Пакетов
Вместо хранения путей и URL внутри конфигов задач, вводится реестр `registries/packages/`. Каждый пакет описывается отдельным YAML-файлом. Это позволяет редактировать источник пакета в одном месте.

### 2. Схема DependencySource
Вводится универсальный формат описания источника пакета, поддерживающий:
*   `local`: Локальный путь (с поддержкой `editable` режима).
*   `git`: Ссылка на репозиторий с указанием `ref` (tag, branch, commit).
*   `pypi`: Установка из индекса пакетов по имени и версии.

### 3. Режимы Исполнения (RUN_MODE)
Поведение системы определяется переменной окружения `RUN_MODE` (по умолчанию `prod`).
*   **Режим `prod`**: RegistryManager загружает базовые конфиги (`package.yaml`). Используются стабильные версии (Git tags, PyPI). Это гарантирует воспроизводимость экспериментов.
*   **Режим `dev`**: RegistryManager ищет файлы оверлеев (`package.dev.yaml`) и мерджит их поверх базовых. Приоритет отдается локальным путям (`type: local`).

### 4. Динамическая композиция vs uv Workspaces
В отличие от традиционных `uv workspaces`, требующих жесткого описания всех членов в корневом `pyproject.toml`, наша система использует **динамическую композицию** зависимостей внутри Execution Plane (контейнеров).

**Преимущества перед uv workspaces и Git Submodules:**
*   **Изоляция репозиториев (No Submodules)**: Пакеты плагинов живут в независимых репозиториях. Их не нужно подключать как `git submodules`, что избавляет от проблем с рекурсивным клонированием и жесткой привязкой коммитов.
*   **Чистота ядра**: Основной проект содержит только зависимости Оркестратора. Динамические плагины не засоряют `uv.lock` хоста и не требуют изменения `pyproject.toml` для каждого нового эксперимента.
*   **Гибкость девелопмента**: Для подключения нового пакета достаточно склонировать его в любую папку и обновить один YAML-файл в реестре.

### 5. Workflow разработки плагина (2026 Edition)
1.  **Инициализация**: Создание отдельного репозитория для пакета (например, `vqa_dataset`).
2.  **Разработка (RUN_MODE=dev)**:
    *   Клонирование репо в любую локальную директорию (например, рядом с основным проектом).
    *   Создание `vqa_dataset.dev.yaml` с `type: local` и `path: /absolute/or/relative/path/to/vqa_dataset`.
    *   Оркестратор автоматически устанавливает его в **editable** режиме.
3.  **Релиз (RUN_MODE=prod)**:
    *   Пуш изменений в репо пакета.
    *   Обновление `vqa_dataset.yaml` ссылкой на Git tag или PyPI версию.
    *   Удаление локальной папки пакета (по желанию).

### 4. RegistryManager
Центральный компонент, отвечающий за:
1.  Сканирование всех директорий реестров.
2.  Валидацию YAML через Pydantic v2 модели.
3.  Разрешение перекрестных ссылок (Cross-validation).
4.  Применение оверлеев в зависимости от `RUN_MODE`.

## Последствия
*   **Плюсы**:
    *   Высокая гибкость при разработке новых компонентов.
    *   Гарантированная воспроизводимость в `prod` режиме.
    *   Отсутствие дублирования конфигураций.
    *   Строгая типизация и понятные ошибки валидации.
*   **Минусы**:
    *   Увеличение количества конфигурационных файлов (решается за счет четкой структуры директорий).

## Структура Директорий
```text
vlmhyperbench/
└── registries/
    ├── packages/       # Атомарные пакеты (DependencySource)
    ├── tasks/          # Типы задач (MLTask)
    ├── metrics/        # Инстансы метрик (имя + параметры)
    ├── reports/        # Инстансы отчетов
    ├── datasets/       # Конфиги датасетов
    ├── runs/           # Конкретные запуски (RunTask)
    └── experiments/    # Планы экспериментов

## Рассмотренные альтернативы (Alternatives Considered)

### Hydra (OmegaConf)
Hydra является стандартом для конфигурации ML-экспериментов, но была отклонена по следующим причинам:
1.  **Отсутствие управления кодом**: Hydra управляет только данными, в то время как нам нужна JIT-инсталляция пакетов через `DependencySource`.
2.  **Слабая кросс-валидация**: Pydantic v2 предоставляет более мощные инструменты для проверки логической связности реестров (например, проверка соответствия метрик типу задачи).
3.  **Тренды 2026**: Наш подход нацелен на генерацию SBOM-манифестов и полную изоляцию плагинов, что в Hydra потребовало бы значительных надстроек.
Подробный анализ см. в [исследовании: Pydantic vs Hydra](../../research/why-pydantic-over-hydra.md).