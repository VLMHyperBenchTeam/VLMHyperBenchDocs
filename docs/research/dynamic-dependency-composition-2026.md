# Исследование: Динамическая композиция зависимостей в 2026 году

## Введение
В 2026 году ландшафт разработки на Python претерпел значительные изменения. Традиционные подходы к управлению монорепозиториями (workspaces) и статическим зависимостям уступают место более гибким, динамическим системам. В этом документе мы анализируем, почему архитектура VLMHyperBench v0.2.0 соответствует самым современным трендам.

## Ключевые тренды 2026 года

### 1. Python как "деталь реализации" (Interpreter as Implementation Detail)
Инструменты нового поколения (uv, Hatch) окончательно абстрагировали интерпретатор. Теперь он воспринимается не как системная зависимость, а как временный ресурс, подтягиваемый под конкретную задачу.
*   **Наш подход**: Оркестратор на хосте имеет минимальный набор зависимостей. Все тяжелые ML-плагины устанавливаются динамически (Just-in-Time) в изолированные контейнеры.
*   **Источник**: [Python: What's Coming in 2026 - The New Stack](https://thenewstack.io/python-whats-coming-in-2026/)

### 2. Смерть "Контейнера-как-Артефакта" (Death of Container-as-Artifact)
В 2026 году Docker-образы стали универсальными и легкими "пустышками". Настоящей единицей деплоя стал Python-пакет (Wheel) со встроенными метаданными.
*   **Наш подход**: Мы не создаем сотни Docker-образов под каждую комбинацию библиотек. Мы используем один базовый образ и динамически собираем окружение через YAML-реестры.
*   **Источник**: [Python Development Trends 2026 - Plain English](https://python.plainenglish.io/python-development-trends-2026-the-quiet-revolution-nobody-saw-coming-97d9a2f99c7f)

### 3. Отказ от Git Submodules в пользу динамических ссылок
Git submodules признаны "антипаттерном" для гибких исследовательских проектов из-за сложности управления версиями и рекурсивного клонирования.
*   **Наш подход**: Пакеты плагинов живут в независимых репозиториях. Связь устанавливается через `DependencySource` в YAML-реестре, что позволяет мгновенно переключаться между `local`, `git` и `pypi` без изменения структуры основного репозитория.

### 4. SBOM (Software Bill of Materials) и Безопасность
С 2026 года стандартом безопасности является предоставление SBOM для любого ML-эксперимента.
*   **Наш подход**: Наш `RegistryManager` автоматически формирует `RuntimeManifest` (фактически SBOM), фиксируя все версии и источники плагинов, использованных в конкретном запуске.

## Почему наш подход лучше uv workspaces и Git Submodules?

| Характеристика | uv Workspaces | Git Submodules | Наш подход (Dynamic Registry) |
| :--- | :--- | :--- | :--- |
| **Связность** | Жесткая (общий `uv.lock`) | Жесткая (commit hashes) | **Нулевая** (изоляция через YAML) |
| **Управление** | В корневом `pyproject.toml` | Команды `git submodule ...` | **Атомарные YAML-файлы** |
| **Разработка** | Локально в монорепо | Требует `git push/pull` | **RUN_MODE=dev** (локальные пути) |
| **Клонирование** | Весь монорепозиторий | Рекурсивное (долго/сложно) | **Только то, что нужно** |
| **Чистота Git** | Засоряет дерево файлов | Усложняет историю | **Чистое ядро + внешние ссылки** |

### Ключевое преимущество перед Submodules
Git Submodules привязывают проект к конкретному коммиту стороннего репозитория. Наш подход позволяет использовать семантическое версионирование (`ref: v1.2.0`) или динамические ветки, что делает обновление плагинов тривиальной задачей, не требующей коммитов в основное ядро бенчмарка.

## Заключение
Архитектура VLMHyperBench v0.2.0 — это не просто система конфигов, а современная платформа управления жизненным циклом ML-исследований, готовая к вызовам 2026 года. Она обеспечивает идеальный баланс между скоростью разработки (`dev` режим с локальными путями) и строгой воспроизводимостью (`prod` режим с фиксированными Git-ссылками).