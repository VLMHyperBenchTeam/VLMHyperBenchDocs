# Сравнительный анализ: Pydantic + Custom Registry vs Hydra

## Введение
При проектировании VLMHyperBench v0.2.0 мы рассматривали [Hydra](https://hydra.cc/) как основной инструмент управления конфигурациями. Однако, учитывая требования 2026 года к динамической композиции и безопасности, было принято решение реализовать собственный `RegistryManager` на базе [Pydantic v2](https://docs.pydantic.dev/).

## Сравнение концепций

| Характеристика | Hydra (OmegaConf) | Наш подход (Pydantic + Registry) |
| :--- | :--- | :--- |
| **Основная цель** | Гибкая параметризация скриптов | Оркестрация динамических окружений |
| **Валидация** | Базовая (типы данных) | Строгая (логика, зависимости, SBOM) |
| **Управление кодом** | Только данные в YAML | Источники кода + JIT-инсталляция |
| **Производительность** | Python-native (медленнее) | Rust-core (Pydantic v2, максимально быстро) |
| **Workflow** | Переопределение через CLI | Авто-оверлеи `.dev.yaml` для пакетов |

## Почему Hydra не подошла

### 1. Отсутствие управления жизненным циклом пакетов
Hydra отлично умеет мерджить YAML-файлы, но она ничего не знает о том, **откуда берется код**, реализующий эти конфиги. В нашем проекте конфиг — это инструкция для Оркестратора:
*   «Склонируй этот Git-репозиторий».
*   «Смонтируй эту локальную папку».
*   «Установи зависимости в editable-режиме».
Наш `DependencySource` решает эти задачи на уровне схемы, что для Hydra является «вне компетенции».

### 2. Строгая кросс-валидация
Нам недостаточно знать, что `metrics` — это список строк. Нам нужно на этапе загрузки проверить:
*   Существуют ли эти метрики в реестре?
*   Разрешены ли они для данного типа `MLTask`?
Pydantic v2 позволяет реализовать такие проверки через `model_validator`, превращая конфигурацию в типизированный граф объектов сразу после парсинга.

### 3. Тренды 2026: SBOM и Runtime Manifest
Современные стандарты требуют генерации манифеста исполнения (Runtime Manifest). Наш `RegistryManager` при загрузке создает атомарный снимок всех разрешенных зависимостей. В Hydra получение такого «замороженного» состояния всей системы (включая версии внешних плагинов) потребовало бы написания сложной обвязки.

## Заключение
Hydra остается прекрасным инструментом для классических ML-задач. Однако для **платформы-бенчмарка**, которая динамически собирает среду исполнения из множества независимых репозиториев, связка **Pydantic v2 + Custom Registry** обеспечивает на порядок более высокий уровень контроля, безопасности и удобства разработки.

Мы не стали «натягивать» Hydra на наши задачи, а создали специализированное решение, вобравшее в себя лучшие идеи (иерархичность, мерджинг), но лишенное её ограничений в контексте оркестрации.